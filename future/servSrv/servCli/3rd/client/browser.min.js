// v5.04.1 on 2019-04-06T22:45:30.614Z
'use strict';
const extend = require('lodash/extend'), isArray = require('lodash/isArray'), isFunction = require('lodash/isFunction'), isObject = require('lodash/isObject'), isUndefined = require('lodash/isUndefined'), negate = require('lodash/negate'), uuid = require('uuid/v4'), generateRequest = require('../generateRequest'), ClientBrowser = function(callServer, options) {
 if (!(this instanceof ClientBrowser)) {
  return new ClientBrowser(callServer, options);
 }
 const defaults = {
  reviver: null,
  replacer: null,
  generator: function() {
   return uuid();
  },
  version: 2
 };
 this.options = extend(defaults, options || {}), this.callServer = callServer;
};
module.exports = ClientBrowser, ClientBrowser.prototype.request = function(method, params, id, callback) {
 const self = this;
 let request = null;
 const isBatch = isArray(method) && isFunction(params);
 if (1 === this.options.version && isBatch) {
  throw new TypeError('JSON-RPC 1.0 does not support batching');
 }
 const isRaw = !isBatch && method && isObject(method) && isFunction(params);
 if (isBatch || isRaw) {
  callback = params, request = method;
 } else {
  isFunction(id) && (callback = id, id = void 0);
  const hasCallback = isFunction(callback);
  try {
   request = generateRequest(method, params, id, {
    generator: this.options.generator,
    version: this.options.version
   });
  } catch (err) {
   if (hasCallback) {
    return callback(err);
   }
   throw err;
  }
  if (!hasCallback) {
   return request;
  }
 }
 let message;
 try {
  message = JSON.stringify(request, this.options.replacer);
 } catch (err) {
  return callback(err);
 }
 return this.callServer(message, function(err, response) {
  self._parseResponse(err, response, callback);
 }), request;
}, ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
 if (err) {
  return void callback(err);
 }
 if (!responseText) {
  return callback();
 }
 let response;
 try {
  response = JSON.parse(responseText, this.options.reviver);
 } catch (err) {
  return callback(err);
 }
 if (3 === callback.length) {
  if (isArray(response)) {
   const isError = function(res) {
    return !isUndefined(res.error);
   };
   return callback(null, response.filter(isError), response.filter(negate(isError)));
  }
  return callback(null, response.error, response.result);
 }
 callback(null, response);
};