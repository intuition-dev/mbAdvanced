// v5.04.1 on 2019-04-06T22:45:30.614Z
'use strict';
const _ = require('lodash'), utils = require('../utils'), events = require('events'), Client = function(server, options) {
 if (1 === arguments.length && _.isPlainObject(server) && (options = server, server = null), 
 !(this instanceof Client)) {
  return new Client(server, options);
 }
 const defaults = {
  reviver: null,
  replacer: null,
  generator: utils.generateId,
  version: 2
 };
 this.options = utils.merge(defaults, options || {}), server && (this.server = server);
};
require('util').inherits(Client, events.EventEmitter), module.exports = Client, 
Client.http = require('./http'), Client.https = require('./https'), Client.tcp = require('./tcp'), 
Client.tls = require('./tls'), Client.browser = require('./browser'), Client.prototype.request = function(method, params, id, callback) {
 const self = this;
 let request = null;
 const isBatch = Array.isArray(method) && 'function' == typeof params;
 if (1 === this.options.version && isBatch) {
  throw new TypeError('JSON-RPC 1.0 does not support batching');
 }
 if (isBatch || !isBatch && method && 'object' == typeof method && 'function' == typeof params) {
  callback = params, request = method;
 } else {
  'function' == typeof id && (callback = id, id = void 0);
  const hasCallback = 'function' == typeof callback;
  try {
   request = utils.request(method, params, id, {
    generator: this.options.generator,
    version: this.options.version
   });
  } catch (err) {
   if (hasCallback) {
    return void callback(err);
   }
   throw err;
  }
  if (!hasCallback) {
   return request;
  }
 }
 return this.emit('request', request), this._request(request, function(err, response) {
  self.emit('response', request, response), self._parseResponse(err, response, callback);
 }), request;
}, Client.prototype._request = function(request, callback) {
 const self = this;
 utils.JSON.stringify(request, this.options, function(err, message) {
  err ? callback(err) : self.server.call(message, function(error, success) {
   callback(null, error || success);
  });
 });
}, Client.prototype._parseResponse = function(err, response, callback) {
 if (err) {
  return callback(err);
 }
 if (!response || 'object' != typeof response) {
  return callback();
 }
 if (3 === callback.length) {
  if (Array.isArray(response)) {
   const isError = function(res) {
    return void 0 !== res.error;
   }, isNotError = function(res) {
    return !isError(res);
   };
   return callback(null, response.filter(isError), response.filter(isNotError));
  }
  return callback(null, response.error, response.result);
 }
 return callback(null, response);
};