// v5.04.1 on 2019-04-06T22:45:30.614Z
'use strict';
const http = require('http'), url = require('url'), utils = require('../utils'), Client = require('../client'), ClientHttp = function(options) {
 if ('string' == typeof options && (options = url.parse(options)), !(this instanceof ClientHttp)) {
  return new ClientHttp(options);
 }
 Client.call(this, options);
 const defaults = utils.merge(this.options, {
  encoding: 'utf8'
 });
 this.options = utils.merge(defaults, options || {});
};
require('util').inherits(ClientHttp, Client), module.exports = ClientHttp, ClientHttp.prototype._request = function(request, callback) {
 const self = this, options = utils.merge({}, this.options);
 utils.JSON.stringify(request, options, function(err, body) {
  if (err) {
   return callback(err);
  }
  options.method = options.method || 'POST';
  const headers = {
   'Content-Length': Buffer.byteLength(body, options.encoding),
   'Content-Type': 'application/json; charset=utf-8',
   Accept: 'application/json'
  };
  options.headers = utils.merge(headers, options.headers || {});
  const req = self._getRequestStream(options);
  self.emit('http request', req), req.on('response', function(res) {
   self.emit('http response', res, req), res.setEncoding(options.encoding);
   let data = '';
   res.on('data', function(chunk) {
    data += chunk;
   }), res.on('end', function() {
    if (res.statusCode < 200 || res.statusCode >= 300) {
     const err = new Error(data);
     err.code = res.statusCode, callback(err);
    } else {
     if (!data || 'string' != typeof data) {
      return callback();
     }
     utils.JSON.parse(data, options, callback);
    }
   });
  }), req.on('timeout', function() {
   req.abort();
  }), req.on('error', function(err) {
   self.emit('http error', err), callback(err), req.abort();
  }), req.end(body);
 });
}, ClientHttp.prototype._getRequestStream = function(options) {
 return http.request(options || {});
};