{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is mbake? mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself. What is MetaBake? MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Summary for Managers MetaBake&trade; allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake&trade; and mbake are open source. The source code is available at github.com/MetaBake&trade; See Resources for related projects. How to install mbake From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here . How to create a Hello World app with mbake ## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername How to run an mbake app (such as Hello World) mbake apps run on any static web server. mbake has a watcher that triggers 'mbake' when you save a file, it also runs your app locally on :8090 port: $ mbakeX -w . Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding. How to generate a sample app with mbake ## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -u Other popular mbake commands mbakeX -c . - Convert Pug/Riot files to useable comp/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs. How to see all mbake options $ mbake $ mbakeX How to make mbake apps serverless To go extreme serverless, we show how to use mbake with Remote environment HTTP hosting (eg: Digital Ocean Linux) Mounting software so you can mount your site folder as a drive Google Firebase/Firestore Go extreme serverless following the steps (Tutorials): Caddy Config with webDAV and Mountain Duck mount Mount webDAV on linux Social SEO AMP Components CMS Electron SPA Meta Cake Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake&trade;. tl;dr $ yarn global add mbake $ mbake $ mbake -v $ cd ModelView $ mbake . NEXT: Go to Caddy Config with webDAV and Mountain Duck mount .","title":"Home"},{"location":"#what-is-mbake","text":"mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself.","title":"What is mbake?"},{"location":"#what-is-metabake","text":"MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Summary for Managers MetaBake&trade; allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake&trade; and mbake are open source. The source code is available at github.com/MetaBake&trade; See Resources for related projects.","title":"What is MetaBake?"},{"location":"#how-to-install-mbake","text":"From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here .","title":"How to install mbake"},{"location":"#how-to-create-a-hello-world-app-with-mbake","text":"## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername","title":"How to create a Hello World app with mbake"},{"location":"#how-to-run-an-mbake-app-such-as-hello-world","text":"mbake apps run on any static web server. mbake has a watcher that triggers 'mbake' when you save a file, it also runs your app locally on :8090 port: $ mbakeX -w . Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding.","title":"How to run an mbake app (such as Hello World)"},{"location":"#how-to-generate-a-sample-app-with-mbake","text":"## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -u","title":"How to generate a sample app with mbake"},{"location":"#other-popular-mbake-commands","text":"mbakeX -c . - Convert Pug/Riot files to useable comp/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs.","title":"Other popular mbake commands"},{"location":"#how-to-see-all-mbake-options","text":"$ mbake $ mbakeX","title":"How to see all mbake options"},{"location":"#how-to-make-mbake-apps-serverless","text":"To go extreme serverless, we show how to use mbake with Remote environment HTTP hosting (eg: Digital Ocean Linux) Mounting software so you can mount your site folder as a drive Google Firebase/Firestore","title":"How to make mbake apps serverless"},{"location":"#go-extreme-serverless-following-the-steps-tutorials","text":"Caddy Config with webDAV and Mountain Duck mount Mount webDAV on linux Social SEO AMP Components CMS Electron SPA Meta Cake Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake.","title":"Go extreme serverless following the steps (Tutorials):"},{"location":"#tldr","text":"$ yarn global add mbake $ mbake $ mbake -v $ cd ModelView $ mbake . NEXT: Go to Caddy Config with webDAV and Mountain Duck mount .","title":"tl;dr"},{"location":"about/","text":"Click for 'THE' mbake Docs low-code = 10X faster web app development. With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it! About MetaBake&trade; mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake&trade; deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake&trade; does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake&trade; we show you how to build complete applications in Pug. With this low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake&trade; approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake&trade; approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake&trade; as the first step into 10X faster web app development. mBake.org productivity is based on three modules: mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake&trade; into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention. About mbake mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com web-app. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About"},{"location":"about/#low-code-10x-faster-web-app-development","text":"","title":"low-code = 10X faster web app development."},{"location":"about/#with-metabakes-modern-development-approach-it-is-not-about-replacing-your-tech-stack-with-another-tech-stack-it-is-about-eliminating-it","text":"","title":"With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it!"},{"location":"about/#about-metabake","text":"mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake&trade; deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake&trade; does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake&trade; we show you how to build complete applications in Pug. With this low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake&trade; approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake&trade; approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake&trade; as the first step into 10X faster web app development.","title":"About MetaBake"},{"location":"about/#mbakeorg-productivity-is-based-on-three-modules","text":"mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake&trade; into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention.","title":"mBake.org productivity is based on three modules:"},{"location":"about/#about-mbake","text":"mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com web-app. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About mbake"},{"location":"amp/","text":"AMP The Accelerated Mobile Pages (AMP) \u2014 is an open-source library that provides a straightforward way to create web pages that are compelling, smooth, and load near instantaneously for users. Web pages and ads published in the AMP open-source format load near instantly, giving users a smooth, more engaging experience on mobile and desktop. When a standard webpage has an AMP counterpart, a link to the AMP page is placed in an HTML tag in the source code of the standard page. Because most AMP pages are easily discoverable by web crawlers, third parties such as search engines and other referring websites can choose to link to the AMP version of a webpage instead of the standard version. AMP HTML is entirely built on existing web technologies. It achieves reliable performance by restricting some parts of HTML, CSS and JavaScript. To make up for those limitations AMP HTML defines a set of custom elements for rich content beyond basic HTML. AMP is useful for SEO and has two benefits for it. One is it will have a Fast label designation on search engine results pages, and the other is that it will be a ranking factor. AMP page example Head To learn what's necessary to create a valid AMP HTML page inspect code in blog app ( $ mbake -b , downloaded in the previous tutorial ). Open file /layout/layout.pug , it is the layout for regular pages, here in head you can see the link to the AMP page: link(rel='amphtml', href='m.html') With this link and the link to regular page in amp-page head this pages are linked to each other, so search engines know that this page has an amp version. Then open /layout/layout-m.pug file, it is the layout for amp-pages. This line tells that this is an AMP page: html('\u26a1') Next lines in head . The charset definition must be the first child of the head tag: meta(charset='utf-8') The AMP runtime must be loaded as the second child of the head tag: script(async, src='https://cdn.ampproject.org/v0.js') then goes a canonical link pointing to the regular HTML, as well required for an AMP page. (If no HTML version exists, it should point to itself): link(rel='canonical', href='index.html') AMP page require a viewport declaration. It's recommended to include initial-scale=1: meta(name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui, viewport-fit=cover\") CSS must be embedded inline. In mbake we use include feature for css, we define css in the separate file, but in the compiled html output css will still be inline: include ../shared/css.pug If you'll open file shared/css.pug you can see that styles wrapped in style(amp-custom=''). it is also required. As for css properties itself there are also some restrictions, for example in amp page version styles can't be used !important is will give a validation error, and the inline style sheet has to be a maximum size of 50 kilobytes, if more it will also give a validation error. Check for more rules on css for AMP pages here . AMP HTML documents must contain the following boilerplate in their head tag: style(amp-boilerplate=''). body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}} Custom scripts in the AMP pages Note that no custom script is supported in the AMP page. The whole point of AMP is to only allow a subset of web technologies to stop your page being slow. Javascript is often the cause of slow websites and so AMP pages do not allow them (except for the AMP scripts themselves), though they've tried to fill in the gap this leaves with amp components which are specially written to not be slow. Body In body tag almost all regular html tags are supported except for certain tags, such as the img tag, are replaced with equivalent or slightly enhanced custom AMP HTML tags, eg: blog/blog/post-*/layout-single-m.pug : amp-img.img__inside(alt='...', src='who.jpg', width='300', height='300') AMP page validation You can test your AMP page on validation errors online here, type in the unput field the page that is needed to be validated (note that you need to enter url to your AMP page, eg: http://example/about/m.html ): https://search.google.com/test/amp or you can validate AMP page directly in browser by adding this string to the end of your page's url, eg: http://example/about/m.html#development=1 If you're validating page in browser, open browser's console and it will show you whether the page has validation errors or validation is successful. Or if you're validating AMP page through search.google.com it will show you the results of validation under the input field on the same page. In the next tutorial you will learn about Components. NEXT: Go to Components .","title":"AMP"},{"location":"amp/#amp","text":"The Accelerated Mobile Pages (AMP) \u2014 is an open-source library that provides a straightforward way to create web pages that are compelling, smooth, and load near instantaneously for users. Web pages and ads published in the AMP open-source format load near instantly, giving users a smooth, more engaging experience on mobile and desktop. When a standard webpage has an AMP counterpart, a link to the AMP page is placed in an HTML tag in the source code of the standard page. Because most AMP pages are easily discoverable by web crawlers, third parties such as search engines and other referring websites can choose to link to the AMP version of a webpage instead of the standard version. AMP HTML is entirely built on existing web technologies. It achieves reliable performance by restricting some parts of HTML, CSS and JavaScript. To make up for those limitations AMP HTML defines a set of custom elements for rich content beyond basic HTML. AMP is useful for SEO and has two benefits for it. One is it will have a Fast label designation on search engine results pages, and the other is that it will be a ranking factor.","title":"AMP"},{"location":"amp/#amp-page-example","text":"","title":"AMP page example"},{"location":"amp/#head","text":"To learn what's necessary to create a valid AMP HTML page inspect code in blog app ( $ mbake -b , downloaded in the previous tutorial ). Open file /layout/layout.pug , it is the layout for regular pages, here in head you can see the link to the AMP page: link(rel='amphtml', href='m.html') With this link and the link to regular page in amp-page head this pages are linked to each other, so search engines know that this page has an amp version. Then open /layout/layout-m.pug file, it is the layout for amp-pages. This line tells that this is an AMP page: html('\u26a1') Next lines in head . The charset definition must be the first child of the head tag: meta(charset='utf-8') The AMP runtime must be loaded as the second child of the head tag: script(async, src='https://cdn.ampproject.org/v0.js') then goes a canonical link pointing to the regular HTML, as well required for an AMP page. (If no HTML version exists, it should point to itself): link(rel='canonical', href='index.html') AMP page require a viewport declaration. It's recommended to include initial-scale=1: meta(name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui, viewport-fit=cover\") CSS must be embedded inline. In mbake we use include feature for css, we define css in the separate file, but in the compiled html output css will still be inline: include ../shared/css.pug If you'll open file shared/css.pug you can see that styles wrapped in style(amp-custom=''). it is also required. As for css properties itself there are also some restrictions, for example in amp page version styles can't be used !important is will give a validation error, and the inline style sheet has to be a maximum size of 50 kilobytes, if more it will also give a validation error. Check for more rules on css for AMP pages here . AMP HTML documents must contain the following boilerplate in their head tag: style(amp-boilerplate=''). body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}","title":"Head"},{"location":"amp/#custom-scripts-in-the-amp-pages","text":"Note that no custom script is supported in the AMP page. The whole point of AMP is to only allow a subset of web technologies to stop your page being slow. Javascript is often the cause of slow websites and so AMP pages do not allow them (except for the AMP scripts themselves), though they've tried to fill in the gap this leaves with amp components which are specially written to not be slow.","title":"Custom scripts in the AMP pages"},{"location":"amp/#body","text":"In body tag almost all regular html tags are supported except for certain tags, such as the img tag, are replaced with equivalent or slightly enhanced custom AMP HTML tags, eg: blog/blog/post-*/layout-single-m.pug : amp-img.img__inside(alt='...', src='who.jpg', width='300', height='300')","title":"Body"},{"location":"amp/#amp-page-validation","text":"You can test your AMP page on validation errors online here, type in the unput field the page that is needed to be validated (note that you need to enter url to your AMP page, eg: http://example/about/m.html ): https://search.google.com/test/amp or you can validate AMP page directly in browser by adding this string to the end of your page's url, eg: http://example/about/m.html#development=1 If you're validating page in browser, open browser's console and it will show you whether the page has validation errors or validation is successful. Or if you're validating AMP page through search.google.com it will show you the results of validation under the input field on the same page. In the next tutorial you will learn about Components. NEXT: Go to Components .","title":"AMP page validation"},{"location":"cms/","text":"Editor CMS CMS App was configured to make operations to some another site (eg: mounted blog), in it one can: edit .md and .yaml files upload images and video files create new posts set publish date for posts (if you will set date in future, the post won't publish until that time) CMS Deploy 1. Assuming you have finished this tutorial Create folder for Blog CMS Editor App, download Blog CMS App to this folder, change cms with your own name: sh $ mkdir cms $ cd cms $ mbakeX -c Create an account (if you haven't one already) and database in Firebase . Navigate to the Service Accounts tab in your database project's settings page. Click the Generate New Private Key button at the bottom of the Firebase Admin SDK section of the Service Accounts tab. After you click the button, a JSON file containing your service account's credentials will be downloaded. Next go to the Authentication tab, click Sign-in method and set Email/Password method to Enabled . To CMS App folder add the following files next to example files accordingly: Rename downloaded in the previous step Firebase Admin SDK file to: serviceAccountKey.json and place it in folder: /cms/CMS . Copy file .env.example to the same folder, rename it to .env . In the Firebase console go to Project Overview tab, on the next screen click </> icon, a popup Add Firebase to your web app will appear. Fill the .env file fields values with according values of your project. Copy file config.js.example in the folder /cms/CMS/wwwAdmin rename it to config.js and change ip url to your server or local ip address. Copy file config.js.example in the folder /cms/CMS/www , rename it to config.js and change ip url to your server or local ip address and change the values of fields apiKey, authDomain, projectId accordingly to the values of your project that you've already retrieved in one of the previous steps. Copy file config.yaml.example in the folder /cms/CMS , rename it to config.yaml , it is necessarily change appMount field value to the path to your mounted folder with site from CDN. You can also change ports or admin password (optional). in folder /cms/CMS run command to install node_modules, compile them and run node: ```sh $ yarn $ tsc $ node index.js // or: // $ nohup node index.js & // if you want node running after the terminal will be closed 1. In folders `/cms/CMS/www` and `/cms/CMS/wwwAdmin` accordingly run command to compile pug: sh $ mbake . 1. in folders `/cms/CMS/www/assets` and `/cms/CMS/wwwAdmin/assets` accordingly run command to compile sass: sh $ mbake -s . 1. Open in browser Blog Admin App: sh [your-ip]:8080 // eg: http://0.0.0.0:8080 ``` Open in browser Blog Editors App: [your-ip]:9080 // eg: http://0.0.0.0:9080 1. Login to Admin App is: 'admin', password is: '123456' (Note: if you have changed the password in config.yaml, then use your new password) Create a new user in Admin App, reset password via received email and then login in Editors app with this user's credentials. In Editors App you can: edit .md and .yaml files upload images and video files create new posts set publish date for posts (if you will set date in future, the post won't publish until that time) All this operations will be applied to your mounted site. Note: that changes will apply after your configured CDN cache will expire. CMS App Structure CMS App consists of two parts: Admin App and Editors App. Admin App In Admin App there is a functionality of CRUD users. It has front end in the wwwAdmin folder and backend written on Node Express. Login to admin App implemented throught basic auth. On login the values from login form fields are compared with the login and password on backend login is hardcoded and password is stored in config.yaml and if they are matched, the login occures. Inspect /cms/wwwAdmin/assets/js/login.js , here we get the login input values and store them in sessionStorage: let formLogin = $(\"#login-form input[name='login']\").val(); let formPassw = $(\"#login-form input[name='password']\").val(); window.sessionStorage.setItem('username', formLogin); window.sessionStorage.setItem('password', formPassw); then inspect /cms/wwwAdmin/assets/js/general.js : /** * basic auth * @param username user name * @param password user password */ constructor(username, password) { this.service = axios.create({ baseURL: window.api[0], auth: { username: username, password: password }, responseType: 'json' }); this.service.interceptors.response.use(function(response) { // Do something with response data console.info('response', response); return response; }, function(error) { // With response error redirect if (typeof error.response === 'undefined') { window.sessionStorage.setItem('errorMessage', 'Network Error'); window.location = '/'; } else if (401 === error.response.status) { window.sessionStorage.setItem('errorMessage', 'Access denied'); window.location = '/'; } return Promise.reject(error); }); } here we check if values are not empty and then go to /cms/wwwAdmin/assets/js/service.js where values are passed to node for check. Here in every request in header axios send username and password and in some request being called we get the response if basic auth is successful or if some error occurs and it is being processed in this function: this.service.interceptors.response.use(function(response) { // Do something with response data console.info('response', response); return response; }, function(error) { // With response error redirect if (typeof error.response === 'undefined') { window.sessionStorage.setItem('errorMessage', 'Network Error'); window.location = '/'; } else if (401 === error.response.status) { window.sessionStorage.setItem('errorMessage', 'Access denied'); window.location = '/'; } return Promise.reject(error); }); and then on node in admin.ts file basicAuth() checks if login and password are matched: adminApp.use(basicAuth({ challenge: true, users: { 'admin': config.secret, 'me': 'openforme' } })); If you will inspect CMS/wwwAdmin/admin/crudEditors/index.pug you'll see that there is an instance of Editors class: let editors = new Editors(getApiService()); which is declared in CMS/wwwAdmin/assets/js/general.js file. From this file we address to the CMS/wwwAdmin/assets/js/services.js file in which there are api requests to the node backend. For example, inspect once again CMS/wwwAdmin/admin/crudEditors/index.pug , here you can see the code that adds a new user: /* * add editor */ $(document).on('click', '#add-editor', function (e) { e.preventDefault(); $(this).attr(\"disabled\", \"disabled\"); $('.loader').addClass('active'); editors .save() .then(() => { $(this).removeAttr(\"disabled\"); $('.loader').removeClass('active'); }); }); editors.save() promise addresses save() method in class Editors in CMS/wwwAdmin/assets/js/general.js file: // add & edit user save(id) { let password = $(\"#editor-form input[name='password']\").val(); let email = $(\"#editor-form input[name='email']\").val(); let name = $(\"#editor-form input[name='name']\").val(); if (id) { // edit user . . . } else { // add user return this.apiService.addEditor(name, email, password) .then((documentRef) => { . . . }) .catch(err => { . . . }); } } here this line this.apiService.addEditor(name, email, password) addresses to the addEditor() method in CMS/wwwAdmin/assets/js/services.js : addEditor(name, email, password) { return this.service.post('/auth/editors', { name: name, email: email, password: password }); } this method call an api request to node. Inspect /lib/admin.ts file, here you can see the endpoint of adding a user to Firestore database: // add user adminApp.post(\"/editors\", (req, res) => { let email = req.body.email; let name = req.body.name; let password = req.body.password; if (typeof email !== 'undefined' && typeof name !== 'undefined' && typeof password !== 'undefined' ) { let editorRef = dbAdminFs.collection('editors').doc(); // get editor id reference firebaseAdmin .get() .auth() .createUser({ // create user email: email, displayName: name, password: password, }) .then(userRecord => { // add user to editors collection return dbAdminFs.collection('editors') .doc(userRecord.uid) .set({ editor_id: editorRef }) .then(_ => { return userRecord; }); }) .then(userRecord => { let firebaseAuth = firebase.get().auth(); console.info('sending reset and verification email to user'); firebaseAuth.sendPasswordResetEmail(email) .then(() => { console.info('email has been sent to user'); }) .catch(function (error) { console.info('email hasn\\'t been sent to user', error); }); return userRecord; }) .then(function (userRecord) { // send response to client // See the UserRecord reference doc for the contents of userRecord. console.info(\"Successfully created new user:\", userRecord.uid); let response = { id: userRecord.uid } res.json(response); }) .catch(function (error) { console.info(\"Error creating new user:\", error); res.status(400); res.send({ error: error.message }); }); } else { res.status(400); res.send({ error: 'parameters missing' }); } }); method createUser() creates a new user in database with email and password, then a new entry with user is created in editors collection and then the method firebaseAuth.sendPasswordResetEmail() sends an email with reset password to the new created user. The other CRUD operations works by the same/similar analogy. Editors App In the Editors App there is functionality for editing .md and .yaml files, creating new post, uploading files and seting a post date, which converts from human readable format to epoch format and is written to dat.yaml . If you will inspect CMS/www/editors/edit/index.pug you'll see that there is an instance of Posts() class: let posts = new Posts(); which is declared in CMS/www/assets/js/general.js file. From this file we address to the CMS/www/assets/js/services.js file in which there are api requests to the node backend. For example, inspect once again CMS/www/editors/edit/index.pug file, here you can see the code of saving the .md , .yaml files: /* * save .md */ $(document).on('click', '.save', function(e) { e.preventDefault(); let postId = $('.blog-item.active').find('li.active').text(); let pathPrefix = $('.blog-item.active').find('span').text(); let md = myCodeMirror.getValue(); $(this).attr(\"disabled\", \"disabled\"); $('.loader').addClass('active'); posts .saveMd(postId, md, pathPrefix) .then(() => { $(this).removeAttr(\"disabled\"); $('.loader').removeClass('active'); $('.notification').removeClass('d-hide').find('.text').text('The content was successfully updated'); setTimeout(function() { $('.notification').addClass('d-hide').find('.text').text(''); }, 4000); }); }); from this file posts.saveMd(postId, md, pathPrefix) method calls the saveMd() method in CMS/www/assets/js/general.js file: saveMd(id, md, pathPrefix) { return apiService.savePostMd(id, md, pathPrefix); } and here savePostMd() method calls the savePostMd api method in CMS/www/assets/js/services.js file: /** * save .md and mbake after edit * @param id .md file name, eg: '/title.md' * @param md .md file content, eg: '###### Lorem ipsum dd dolor sit {.title}' * @param pathPrefix path to .md file, eg: 'blog/post-4' */ savePostMd(id, md, pathPrefix) { return this.service.put('/editors/post', md, { headers: { 'Content-Type': 'text/plain' }, params: { post_id: id, pathPrefix: pathPrefix } }); } the savePostMd() method call an api request to node. Now inspect /lib/editor.ts , here is the endpoint for saving .md and .yaml files: // update .md file appE.put(\"/post\", (req, res) => { let post_id = req.query.post_id; let pathPrefix = req.query.pathPrefix; if (typeof post_id !== 'undefined') { let md = '/' + pathPrefix + post_id; let fileOps = new FileOps(config.appMount); fileOps.write(md, req.body); let runMbake = new MBake(); let postsFolder = post_id.substr(0, post_id.indexOf('/')); runMbake.itemizeNBake(config.appMount + '/' + postsFolder); runMbake.comps(config.appMount); res.send('OK'); } else { res.status(400); res.send({ error: 'no post_id' }); } }); you can see that a new instance of FileOps() class is created it is imported from node modules mbake library, and the method fileOps.write() saves the file with the new changes. Then we create a new instance of class MBake which is also imported from node modules and then mbake is triggered to compile the changes to html with the methods runMbake.itemizeNBake() and runMbake.comps() . The other functionality works by the same/similar analogy. In the next tutorial you will learn about Electron SPA. NEXT: Go to Electron SPA .","title":"CMS"},{"location":"cms/#editor-cms","text":"CMS App was configured to make operations to some another site (eg: mounted blog), in it one can: edit .md and .yaml files upload images and video files create new posts set publish date for posts (if you will set date in future, the post won't publish until that time)","title":"Editor CMS"},{"location":"cms/#cms-deploy","text":"1. Assuming you have finished this tutorial Create folder for Blog CMS Editor App, download Blog CMS App to this folder, change cms with your own name: sh $ mkdir cms $ cd cms $ mbakeX -c Create an account (if you haven't one already) and database in Firebase . Navigate to the Service Accounts tab in your database project's settings page. Click the Generate New Private Key button at the bottom of the Firebase Admin SDK section of the Service Accounts tab. After you click the button, a JSON file containing your service account's credentials will be downloaded. Next go to the Authentication tab, click Sign-in method and set Email/Password method to Enabled . To CMS App folder add the following files next to example files accordingly: Rename downloaded in the previous step Firebase Admin SDK file to: serviceAccountKey.json and place it in folder: /cms/CMS . Copy file .env.example to the same folder, rename it to .env . In the Firebase console go to Project Overview tab, on the next screen click </> icon, a popup Add Firebase to your web app will appear. Fill the .env file fields values with according values of your project. Copy file config.js.example in the folder /cms/CMS/wwwAdmin rename it to config.js and change ip url to your server or local ip address. Copy file config.js.example in the folder /cms/CMS/www , rename it to config.js and change ip url to your server or local ip address and change the values of fields apiKey, authDomain, projectId accordingly to the values of your project that you've already retrieved in one of the previous steps. Copy file config.yaml.example in the folder /cms/CMS , rename it to config.yaml , it is necessarily change appMount field value to the path to your mounted folder with site from CDN. You can also change ports or admin password (optional). in folder /cms/CMS run command to install node_modules, compile them and run node: ```sh $ yarn $ tsc $ node index.js // or: // $ nohup node index.js & // if you want node running after the terminal will be closed 1. In folders `/cms/CMS/www` and `/cms/CMS/wwwAdmin` accordingly run command to compile pug: sh $ mbake . 1. in folders `/cms/CMS/www/assets` and `/cms/CMS/wwwAdmin/assets` accordingly run command to compile sass: sh $ mbake -s . 1. Open in browser Blog Admin App: sh [your-ip]:8080 // eg: http://0.0.0.0:8080 ``` Open in browser Blog Editors App: [your-ip]:9080 // eg: http://0.0.0.0:9080 1. Login to Admin App is: 'admin', password is: '123456' (Note: if you have changed the password in config.yaml, then use your new password) Create a new user in Admin App, reset password via received email and then login in Editors app with this user's credentials. In Editors App you can: edit .md and .yaml files upload images and video files create new posts set publish date for posts (if you will set date in future, the post won't publish until that time) All this operations will be applied to your mounted site. Note: that changes will apply after your configured CDN cache will expire.","title":"CMS Deploy"},{"location":"cms/#cms-app-structure","text":"CMS App consists of two parts: Admin App and Editors App.","title":"CMS App Structure"},{"location":"cms/#admin-app","text":"In Admin App there is a functionality of CRUD users. It has front end in the wwwAdmin folder and backend written on Node Express. Login to admin App implemented throught basic auth. On login the values from login form fields are compared with the login and password on backend login is hardcoded and password is stored in config.yaml and if they are matched, the login occures. Inspect /cms/wwwAdmin/assets/js/login.js , here we get the login input values and store them in sessionStorage: let formLogin = $(\"#login-form input[name='login']\").val(); let formPassw = $(\"#login-form input[name='password']\").val(); window.sessionStorage.setItem('username', formLogin); window.sessionStorage.setItem('password', formPassw); then inspect /cms/wwwAdmin/assets/js/general.js : /** * basic auth * @param username user name * @param password user password */ constructor(username, password) { this.service = axios.create({ baseURL: window.api[0], auth: { username: username, password: password }, responseType: 'json' }); this.service.interceptors.response.use(function(response) { // Do something with response data console.info('response', response); return response; }, function(error) { // With response error redirect if (typeof error.response === 'undefined') { window.sessionStorage.setItem('errorMessage', 'Network Error'); window.location = '/'; } else if (401 === error.response.status) { window.sessionStorage.setItem('errorMessage', 'Access denied'); window.location = '/'; } return Promise.reject(error); }); } here we check if values are not empty and then go to /cms/wwwAdmin/assets/js/service.js where values are passed to node for check. Here in every request in header axios send username and password and in some request being called we get the response if basic auth is successful or if some error occurs and it is being processed in this function: this.service.interceptors.response.use(function(response) { // Do something with response data console.info('response', response); return response; }, function(error) { // With response error redirect if (typeof error.response === 'undefined') { window.sessionStorage.setItem('errorMessage', 'Network Error'); window.location = '/'; } else if (401 === error.response.status) { window.sessionStorage.setItem('errorMessage', 'Access denied'); window.location = '/'; } return Promise.reject(error); }); and then on node in admin.ts file basicAuth() checks if login and password are matched: adminApp.use(basicAuth({ challenge: true, users: { 'admin': config.secret, 'me': 'openforme' } })); If you will inspect CMS/wwwAdmin/admin/crudEditors/index.pug you'll see that there is an instance of Editors class: let editors = new Editors(getApiService()); which is declared in CMS/wwwAdmin/assets/js/general.js file. From this file we address to the CMS/wwwAdmin/assets/js/services.js file in which there are api requests to the node backend. For example, inspect once again CMS/wwwAdmin/admin/crudEditors/index.pug , here you can see the code that adds a new user: /* * add editor */ $(document).on('click', '#add-editor', function (e) { e.preventDefault(); $(this).attr(\"disabled\", \"disabled\"); $('.loader').addClass('active'); editors .save() .then(() => { $(this).removeAttr(\"disabled\"); $('.loader').removeClass('active'); }); }); editors.save() promise addresses save() method in class Editors in CMS/wwwAdmin/assets/js/general.js file: // add & edit user save(id) { let password = $(\"#editor-form input[name='password']\").val(); let email = $(\"#editor-form input[name='email']\").val(); let name = $(\"#editor-form input[name='name']\").val(); if (id) { // edit user . . . } else { // add user return this.apiService.addEditor(name, email, password) .then((documentRef) => { . . . }) .catch(err => { . . . }); } } here this line this.apiService.addEditor(name, email, password) addresses to the addEditor() method in CMS/wwwAdmin/assets/js/services.js : addEditor(name, email, password) { return this.service.post('/auth/editors', { name: name, email: email, password: password }); } this method call an api request to node. Inspect /lib/admin.ts file, here you can see the endpoint of adding a user to Firestore database: // add user adminApp.post(\"/editors\", (req, res) => { let email = req.body.email; let name = req.body.name; let password = req.body.password; if (typeof email !== 'undefined' && typeof name !== 'undefined' && typeof password !== 'undefined' ) { let editorRef = dbAdminFs.collection('editors').doc(); // get editor id reference firebaseAdmin .get() .auth() .createUser({ // create user email: email, displayName: name, password: password, }) .then(userRecord => { // add user to editors collection return dbAdminFs.collection('editors') .doc(userRecord.uid) .set({ editor_id: editorRef }) .then(_ => { return userRecord; }); }) .then(userRecord => { let firebaseAuth = firebase.get().auth(); console.info('sending reset and verification email to user'); firebaseAuth.sendPasswordResetEmail(email) .then(() => { console.info('email has been sent to user'); }) .catch(function (error) { console.info('email hasn\\'t been sent to user', error); }); return userRecord; }) .then(function (userRecord) { // send response to client // See the UserRecord reference doc for the contents of userRecord. console.info(\"Successfully created new user:\", userRecord.uid); let response = { id: userRecord.uid } res.json(response); }) .catch(function (error) { console.info(\"Error creating new user:\", error); res.status(400); res.send({ error: error.message }); }); } else { res.status(400); res.send({ error: 'parameters missing' }); } }); method createUser() creates a new user in database with email and password, then a new entry with user is created in editors collection and then the method firebaseAuth.sendPasswordResetEmail() sends an email with reset password to the new created user. The other CRUD operations works by the same/similar analogy.","title":"Admin App"},{"location":"cms/#editors-app","text":"In the Editors App there is functionality for editing .md and .yaml files, creating new post, uploading files and seting a post date, which converts from human readable format to epoch format and is written to dat.yaml . If you will inspect CMS/www/editors/edit/index.pug you'll see that there is an instance of Posts() class: let posts = new Posts(); which is declared in CMS/www/assets/js/general.js file. From this file we address to the CMS/www/assets/js/services.js file in which there are api requests to the node backend. For example, inspect once again CMS/www/editors/edit/index.pug file, here you can see the code of saving the .md , .yaml files: /* * save .md */ $(document).on('click', '.save', function(e) { e.preventDefault(); let postId = $('.blog-item.active').find('li.active').text(); let pathPrefix = $('.blog-item.active').find('span').text(); let md = myCodeMirror.getValue(); $(this).attr(\"disabled\", \"disabled\"); $('.loader').addClass('active'); posts .saveMd(postId, md, pathPrefix) .then(() => { $(this).removeAttr(\"disabled\"); $('.loader').removeClass('active'); $('.notification').removeClass('d-hide').find('.text').text('The content was successfully updated'); setTimeout(function() { $('.notification').addClass('d-hide').find('.text').text(''); }, 4000); }); }); from this file posts.saveMd(postId, md, pathPrefix) method calls the saveMd() method in CMS/www/assets/js/general.js file: saveMd(id, md, pathPrefix) { return apiService.savePostMd(id, md, pathPrefix); } and here savePostMd() method calls the savePostMd api method in CMS/www/assets/js/services.js file: /** * save .md and mbake after edit * @param id .md file name, eg: '/title.md' * @param md .md file content, eg: '###### Lorem ipsum dd dolor sit {.title}' * @param pathPrefix path to .md file, eg: 'blog/post-4' */ savePostMd(id, md, pathPrefix) { return this.service.put('/editors/post', md, { headers: { 'Content-Type': 'text/plain' }, params: { post_id: id, pathPrefix: pathPrefix } }); } the savePostMd() method call an api request to node. Now inspect /lib/editor.ts , here is the endpoint for saving .md and .yaml files: // update .md file appE.put(\"/post\", (req, res) => { let post_id = req.query.post_id; let pathPrefix = req.query.pathPrefix; if (typeof post_id !== 'undefined') { let md = '/' + pathPrefix + post_id; let fileOps = new FileOps(config.appMount); fileOps.write(md, req.body); let runMbake = new MBake(); let postsFolder = post_id.substr(0, post_id.indexOf('/')); runMbake.itemizeNBake(config.appMount + '/' + postsFolder); runMbake.comps(config.appMount); res.send('OK'); } else { res.status(400); res.send({ error: 'no post_id' }); } }); you can see that a new instance of FileOps() class is created it is imported from node modules mbake library, and the method fileOps.write() saves the file with the new changes. Then we create a new instance of class MBake which is also imported from node modules and then mbake is triggered to compile the changes to html with the methods runMbake.itemizeNBake() and runMbake.comps() . The other functionality works by the same/similar analogy. In the next tutorial you will learn about Electron SPA. NEXT: Go to Electron SPA .","title":"Editors App"},{"location":"electron/","text":"Electron SPA Electron is built on Chromium and the navigation model is pretty much the exact same as any other web browser. Electron needs ROOT, as / in electron means root of drive; not root of http server. There is no http server. Not having to go to a remote web server means loading pages in Electron should be pretty quick. Electron has node and it lets you start Chrome. So you can build a Windows app, or an OSX app. Electron apps are normally SPA. Our example also in one page. Run the command to extract an Electron SPA App example: $ mbakeX -e From the /elect folder install node modules: $ yarn Compile .pug in /elect/app/www folder and .scss/.sass in /elect/app/www/assets , eg: $ mbake . $ mbake -s . Run the app from the elect/app folder with the command: $ npm start The application should show up. Inspect /elect/app/www/assets/router/spa-router.js , here you can see code: SPArouter.zone = '#router'; . . . SPArouter.init(onNavigate); function onNavigate (evt) { if (evt.detail.type == SPArouter.NavSTART) { //start //$('#router').fadeTo(100,.2); } else if (evt.detail.type == SPArouter.NavDONE) { $(SPArouter.zone).html(evt.detail.newContent); //$('#router').fadeTo(100,1); window.scrollTo(0, 0); } } and here /elect/app/www/layout/layout.pug you can see div #router : .column #router block main It intercepts href and replaces a #div. So every page content will place in #router div and for every page just the contents of this div is changed. Inspect /elect/app/www/index.pug it the first page that is shown right after the app is run: extends /layout/layout block main .pad. Oh Hi this page extends the /elect/app/www/layout/layout.pug and this means that block main is inside the #router div. Inspect /elect/app/www/screen/tabulator/index.pug it the second page, it shows the Tabulator.js table with the news from different sources that are get through api: block main .pad #feed-table.table-custom script. loadjs.ready(['services'], function () { let apiService = new ApiService(); apiService.getFeedData() .then(feed => { //console.info('feed.data.articles', feed.data.articles); this.table = new Tabulator(\"#feed-table\", { data:feed.data.articles,// assign data to table layout:\"fitColumns\", // fit columns to width of table columns:[ // Define Table Columns {title:\"id\", field:\"id\", visible:false}, {title:\"Source\", field:\"source.name\", align:\"left\"}, {title:\"Author\", field:\"author\", align:\"left\"}, {title:\"Title\", field:\"title\", align:\"left\"}, {title:\"Content\", field:\"content\", align:\"left\"} ], rowClick:(e, row) => { // fill the form fields this.activeRow = row; var row = row.getData(); window.rowUid = row.id; $('input[name=\"name\"]').val(row.name); $('input[name=\"email\"]').val(row.email); $('html, body').animate({ // scroll to form scrollTop: $(\"#editor-form\").offset().top }, 500); }, }); }); }); In the next tutorial you will learn about Meta Cake. NEXT: Go to Meta Cake .","title":"Electron SPA"},{"location":"electron/#electron-spa","text":"Electron is built on Chromium and the navigation model is pretty much the exact same as any other web browser. Electron needs ROOT, as / in electron means root of drive; not root of http server. There is no http server. Not having to go to a remote web server means loading pages in Electron should be pretty quick. Electron has node and it lets you start Chrome. So you can build a Windows app, or an OSX app. Electron apps are normally SPA. Our example also in one page. Run the command to extract an Electron SPA App example: $ mbakeX -e From the /elect folder install node modules: $ yarn Compile .pug in /elect/app/www folder and .scss/.sass in /elect/app/www/assets , eg: $ mbake . $ mbake -s . Run the app from the elect/app folder with the command: $ npm start The application should show up. Inspect /elect/app/www/assets/router/spa-router.js , here you can see code: SPArouter.zone = '#router'; . . . SPArouter.init(onNavigate); function onNavigate (evt) { if (evt.detail.type == SPArouter.NavSTART) { //start //$('#router').fadeTo(100,.2); } else if (evt.detail.type == SPArouter.NavDONE) { $(SPArouter.zone).html(evt.detail.newContent); //$('#router').fadeTo(100,1); window.scrollTo(0, 0); } } and here /elect/app/www/layout/layout.pug you can see div #router : .column #router block main It intercepts href and replaces a #div. So every page content will place in #router div and for every page just the contents of this div is changed. Inspect /elect/app/www/index.pug it the first page that is shown right after the app is run: extends /layout/layout block main .pad. Oh Hi this page extends the /elect/app/www/layout/layout.pug and this means that block main is inside the #router div. Inspect /elect/app/www/screen/tabulator/index.pug it the second page, it shows the Tabulator.js table with the news from different sources that are get through api: block main .pad #feed-table.table-custom script. loadjs.ready(['services'], function () { let apiService = new ApiService(); apiService.getFeedData() .then(feed => { //console.info('feed.data.articles', feed.data.articles); this.table = new Tabulator(\"#feed-table\", { data:feed.data.articles,// assign data to table layout:\"fitColumns\", // fit columns to width of table columns:[ // Define Table Columns {title:\"id\", field:\"id\", visible:false}, {title:\"Source\", field:\"source.name\", align:\"left\"}, {title:\"Author\", field:\"author\", align:\"left\"}, {title:\"Title\", field:\"title\", align:\"left\"}, {title:\"Content\", field:\"content\", align:\"left\"} ], rowClick:(e, row) => { // fill the form fields this.activeRow = row; var row = row.getData(); window.rowUid = row.id; $('input[name=\"name\"]').val(row.name); $('input[name=\"email\"]').val(row.email); $('html, body').animate({ // scroll to form scrollTop: $(\"#editor-form\").offset().top }, 500); }, }); }); }); In the next tutorial you will learn about Meta Cake. NEXT: Go to Meta Cake .","title":"Electron SPA"},{"location":"meta-cake/","text":"Meta Cake Meta Cake is a library of plugins or components. It is also a domain specific language, specific component to your app. Ideally not a programmer can use it. And Meta Cake is the next level of productivity, since components are more productive.","title":"Meta Cake"},{"location":"meta-cake/#meta-cake","text":"Meta Cake is a library of plugins or components. It is also a domain specific language, specific component to your app. Ideally not a programmer can use it. And Meta Cake is the next level of productivity, since components are more productive.","title":"Meta Cake"},{"location":"res/","text":"Awesome low-code list of MetaBake&trade; resources https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Resources"},{"location":"res/#awesome-low-code-list-of-metabake-resources","text":"https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Awesome low-code list of MetaBake&trade; resources"},{"location":"seo/","text":"Social SEO SEO stands for Search Engine Optimization. Including social media metadata in all new pieces of content allows you to optimize for sharing Twitter, Facebook, Google+ and Pinerest by defining exactly how titles, descriptions, images and more appear in social streams. The implications for SEO are also significant. The right data, including optimized images, helps content to spread, which often leads to increased links and mentions. You can find many templates of SEO meta tags in the internet (eg: here ) In mbake you can write values for each meta tag and for each page in the page's dat.yaml file and then in the layout address to these fields in meta tags. This allows you to define meta tags just once (in the layout) amd then access to them on each page from dat.yaml file. You can inspect code in the example blog app: $ mbake -b compile files and run the app: $ mbakeX -c . $ cd blog $ mbake -i . $ cd ../assets $ mbakeX -s . $ mbakeX -w . in the /layout/layout.pug file you can see defined SEO meta tags in head : meta(name='description', content=content_text) //- Schema.org markup for Google+ meta(itemprop='name', content=title) meta(itemprop='description', content=content_text) meta(itemprop='image', content=image) //- Twitter Card data meta(name='twitter:title', content=title) meta(name='twitter:description', content=content_text) meta(name='twitter:image', content=image) //- Open Graph data meta(property='og:title', content=title) meta(property='og:image', content=image) meta(property='og:description', content=comment) Notice that instead of their value (text or url) there are variables. Now open /blog/post-*/dat.yaml , here you can see that the variables from the layout's head are defined here with their value as text or url, eg: title: >- Quisque faucibus lacinia turpis id fermentum. Sed eu velit massa. Etiam molestie, ante at imperdiet ornare, sapien nulla volutpat nunc. image: >- https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbAOd1CI4oPfTryZpo_rAyZXf9ltuPAvRv45XPGDghPSLii5We content_text: >- Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod The values of this variables will be placed in html head SEO meta tags at the compiled time, in html when you will compile index.pug to index.html In the next tutorial you will learn about AMP. NEXT: Go to AMP .","title":"Social SEO"},{"location":"seo/#social-seo","text":"SEO stands for Search Engine Optimization. Including social media metadata in all new pieces of content allows you to optimize for sharing Twitter, Facebook, Google+ and Pinerest by defining exactly how titles, descriptions, images and more appear in social streams. The implications for SEO are also significant. The right data, including optimized images, helps content to spread, which often leads to increased links and mentions. You can find many templates of SEO meta tags in the internet (eg: here ) In mbake you can write values for each meta tag and for each page in the page's dat.yaml file and then in the layout address to these fields in meta tags. This allows you to define meta tags just once (in the layout) amd then access to them on each page from dat.yaml file. You can inspect code in the example blog app: $ mbake -b compile files and run the app: $ mbakeX -c . $ cd blog $ mbake -i . $ cd ../assets $ mbakeX -s . $ mbakeX -w . in the /layout/layout.pug file you can see defined SEO meta tags in head : meta(name='description', content=content_text) //- Schema.org markup for Google+ meta(itemprop='name', content=title) meta(itemprop='description', content=content_text) meta(itemprop='image', content=image) //- Twitter Card data meta(name='twitter:title', content=title) meta(name='twitter:description', content=content_text) meta(name='twitter:image', content=image) //- Open Graph data meta(property='og:title', content=title) meta(property='og:image', content=image) meta(property='og:description', content=comment) Notice that instead of their value (text or url) there are variables. Now open /blog/post-*/dat.yaml , here you can see that the variables from the layout's head are defined here with their value as text or url, eg: title: >- Quisque faucibus lacinia turpis id fermentum. Sed eu velit massa. Etiam molestie, ante at imperdiet ornare, sapien nulla volutpat nunc. image: >- https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbAOd1CI4oPfTryZpo_rAyZXf9ltuPAvRv45XPGDghPSLii5We content_text: >- Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod The values of this variables will be placed in html head SEO meta tags at the compiled time, in html when you will compile index.pug to index.html In the next tutorial you will learn about AMP. NEXT: Go to AMP .","title":"Social SEO"},{"location":"source_config_n_mount/","text":"Caddy Config with webDAV and Mountain Duck mount Setup up an enviroment in the cloud, e.g. Digital Ocean . Setup a Web IDE account, e.g. CodeAnywhere . Install yarn, mbake, typescript Install Caddy with webDAV plugin, eg: $ curl https://getcaddy.com | bash -s personal http.webdav Add Caddyfile to the root folder and config it, eg: :8080 { #cdn would go to this root /root/www gzip mime .css text/css # set user for the /webdav path basicauth /webdav admin 123123 webdav /webdav log ../log1 errors ../err1 } Create folder www and in this folder download blog source: $ mkdir www $ cd www $ mbake -b compile files: $ mbake -c . $ cd assets $ mbakeX -s . $ cd .. $ cd blog $ mbake -i . Run Caddy server, from the root folder where Caddyfile is: $ caddy -conf Caddyfile // or $ caddy // or (to leave caddy server running after you'll quit the terminal or close the CA tab) $ nohup caddy & In browser open the url, change ip address to your ip address, the site should work: http://0.0.0.0:8080/ Install on Mac Mountain Duck you may choose a different webDAV mount software. Mount replaces FTP. In Mountain Duck, create a new webDAV (HTTP) connection. Fill the fields for server and username , path -- /webdav/www and port with your credentials, then click connect , it will ask for username and password from the Caddyfile webDAV config. You have mounted folder of your site from remote environment on your local PC and you can edit it. Create an account on CDN77 if you don't already have one. Go to CDN 77 and create a Resource for your remote environment hosting: select My Origin , select http and in the domain field type in the your ip address and port. Go to tab other settings and select cache expiry -- 10 minutes , then go to Purge tab and purge all files . This action is needed to reduce the time of files caching. To verify that the mount is working, you can edit some file and check if changes applied in the browser via the Endpoint URL from your recently created CDN Resource. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount webDAV on linux. NEXT: Go to Mount webDAV on linux .","title":"Caddy Config with webDAV and Mountain Duck mount"},{"location":"source_config_n_mount/#caddy-config-with-webdav-and-mountain-duck-mount","text":"Setup up an enviroment in the cloud, e.g. Digital Ocean . Setup a Web IDE account, e.g. CodeAnywhere . Install yarn, mbake, typescript Install Caddy with webDAV plugin, eg: $ curl https://getcaddy.com | bash -s personal http.webdav Add Caddyfile to the root folder and config it, eg: :8080 { #cdn would go to this root /root/www gzip mime .css text/css # set user for the /webdav path basicauth /webdav admin 123123 webdav /webdav log ../log1 errors ../err1 } Create folder www and in this folder download blog source: $ mkdir www $ cd www $ mbake -b compile files: $ mbake -c . $ cd assets $ mbakeX -s . $ cd .. $ cd blog $ mbake -i . Run Caddy server, from the root folder where Caddyfile is: $ caddy -conf Caddyfile // or $ caddy // or (to leave caddy server running after you'll quit the terminal or close the CA tab) $ nohup caddy & In browser open the url, change ip address to your ip address, the site should work: http://0.0.0.0:8080/ Install on Mac Mountain Duck you may choose a different webDAV mount software. Mount replaces FTP. In Mountain Duck, create a new webDAV (HTTP) connection. Fill the fields for server and username , path -- /webdav/www and port with your credentials, then click connect , it will ask for username and password from the Caddyfile webDAV config. You have mounted folder of your site from remote environment on your local PC and you can edit it. Create an account on CDN77 if you don't already have one. Go to CDN 77 and create a Resource for your remote environment hosting: select My Origin , select http and in the domain field type in the your ip address and port. Go to tab other settings and select cache expiry -- 10 minutes , then go to Purge tab and purge all files . This action is needed to reduce the time of files caching. To verify that the mount is working, you can edit some file and check if changes applied in the browser via the Endpoint URL from your recently created CDN Resource. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount webDAV on linux. NEXT: Go to Mount webDAV on linux .","title":"Caddy Config with webDAV and Mountain Duck mount"},{"location":"tags/","text":"Components Guidelines as to when to use Tag/Components RULE : Must use Contexted DOM selector|query (check RIOT Guide for jq and w/o jq) // Contexted jQuery $('p', this.root) // Contexted Query Selector this.root.querySelectorAll('p') It is not the best practice to have an event on the dom, eg: button(onclick='{this.handleClick}') button text in html attribute, instead it's better register and event to a dom like this: $('button', this.root).click(function() {...}); It is a good practice to use the life cycle event mount, eg: this.on('mount', function() {...}); and use this.update() , eg: this.on('mount', function() { // right after the component is mounted on the page let THIZ = this; // this is the tag . . . THIZ.update({num: +arg1 - +arg2}); }); A component is architected so it is easy for the page to use - even if it is hard to write the tag. Other: - Main point of page/screen should be pug/include - so it's easy to see what a page does - But there are things around the main thing supporting it. Those could be components. If: - There is some .js that we can hide in the component - Could host the comp.js outside of the web app, think: banner ad. Encapsulation! - Normally each component, when mounted on the page, is passed to the ViewModel. Binding is inside the component. eg: options - component does update() (using virtual DOM as is current fad) - When possible make component as much attribute or dom based. eg yield, and again ... attributes over .js - CSS style could be scoped - Scoped CSS :scope - Could be used in another webapps. eg: contact us. - There could be multiple instance of a component on a page. - Leverage component lifecycle events (eg mount) as needed. - Avoid component mixins. - Should be able to work external - Should change based on html component attributes. Use attributes when you can. component should not reference or affect other things on a page. It is one way communication from page. If anything: component broadcasts events FlipTag Here you can check the example of an advanced FlipTag component. Download and unpack or git clone the project . From the root ( /flip ) folder, compile .pug : mbakeX -c . Use component with the attributes in your index.pug : flipcard(direction='y', style='width:315px;height:100px;display:none') .front h2 Flip Vertical button(onclick='{toggle}') Flip .back(style='background:#a40') h2 I'm Flipped button(onclick='{toggle}') Back You can access any method from flip-comp.pug in your index.pug file, eg: .button(onclick='{toggle}') As well as element's attributes, you define them also in index.pug : flipcard(direction='y') and then they are used in flip-comp.pug . riot2 Here is another example of an advanced riot2 component. The <yield> component that is used here is a special riot core feature that allows you to inject and compile the content of any custom component inside its template in runtime. In this example html which is passed to a boa-comp.pug component from index.pug specified under the boa-comp html-tag/component (two form inputs): boa-comp(type='sum', text='Check Sum!') input(type='number', placeholder='Enter any number') input(type='number', placeholder='Enter any number') And this html in compiled html output will be inserted exactly in the place where the <yield/> html-tag/component is specified in a riot tag: boa-comp form <yield /> .h-row button(type='submit') {opts.text} p.num { num } The idea of this component is to use it, without knowing or investigating which code is written and how it works in boa-comp.pug component, but simply using it in your html by passing html parameters to it, eg: type='sum', text='Check Sum!' And the component will do all calculation, depending only on this parameters that are being passed. Ideally even not a programmer can use it. It is a next level of productivity, since components are more productive. In the next tutorial you will learn about CMS. NEXT: Go to Editor CMS .","title":"Components"},{"location":"tags/#components","text":"","title":"Components"},{"location":"tags/#guidelines-as-to-when-to-use-tagcomponents","text":"RULE : Must use Contexted DOM selector|query (check RIOT Guide for jq and w/o jq) // Contexted jQuery $('p', this.root) // Contexted Query Selector this.root.querySelectorAll('p') It is not the best practice to have an event on the dom, eg: button(onclick='{this.handleClick}') button text in html attribute, instead it's better register and event to a dom like this: $('button', this.root).click(function() {...}); It is a good practice to use the life cycle event mount, eg: this.on('mount', function() {...}); and use this.update() , eg: this.on('mount', function() { // right after the component is mounted on the page let THIZ = this; // this is the tag . . . THIZ.update({num: +arg1 - +arg2}); }); A component is architected so it is easy for the page to use - even if it is hard to write the tag. Other: - Main point of page/screen should be pug/include - so it's easy to see what a page does - But there are things around the main thing supporting it. Those could be components. If: - There is some .js that we can hide in the component - Could host the comp.js outside of the web app, think: banner ad. Encapsulation! - Normally each component, when mounted on the page, is passed to the ViewModel. Binding is inside the component. eg: options - component does update() (using virtual DOM as is current fad) - When possible make component as much attribute or dom based. eg yield, and again ... attributes over .js - CSS style could be scoped - Scoped CSS :scope - Could be used in another webapps. eg: contact us. - There could be multiple instance of a component on a page. - Leverage component lifecycle events (eg mount) as needed. - Avoid component mixins. - Should be able to work external - Should change based on html component attributes. Use attributes when you can. component should not reference or affect other things on a page. It is one way communication from page. If anything: component broadcasts events","title":"Guidelines as to when to use Tag/Components"},{"location":"tags/#fliptag","text":"Here you can check the example of an advanced FlipTag component. Download and unpack or git clone the project . From the root ( /flip ) folder, compile .pug : mbakeX -c . Use component with the attributes in your index.pug : flipcard(direction='y', style='width:315px;height:100px;display:none') .front h2 Flip Vertical button(onclick='{toggle}') Flip .back(style='background:#a40') h2 I'm Flipped button(onclick='{toggle}') Back You can access any method from flip-comp.pug in your index.pug file, eg: .button(onclick='{toggle}') As well as element's attributes, you define them also in index.pug : flipcard(direction='y') and then they are used in flip-comp.pug .","title":"FlipTag"},{"location":"tags/#riot2","text":"Here is another example of an advanced riot2 component. The <yield> component that is used here is a special riot core feature that allows you to inject and compile the content of any custom component inside its template in runtime. In this example html which is passed to a boa-comp.pug component from index.pug specified under the boa-comp html-tag/component (two form inputs): boa-comp(type='sum', text='Check Sum!') input(type='number', placeholder='Enter any number') input(type='number', placeholder='Enter any number') And this html in compiled html output will be inserted exactly in the place where the <yield/> html-tag/component is specified in a riot tag: boa-comp form <yield /> .h-row button(type='submit') {opts.text} p.num { num } The idea of this component is to use it, without knowing or investigating which code is written and how it works in boa-comp.pug component, but simply using it in your html by passing html parameters to it, eg: type='sum', text='Check Sum!' And the component will do all calculation, depending only on this parameters that are being passed. Ideally even not a programmer can use it. It is a next level of productivity, since components are more productive. In the next tutorial you will learn about CMS. NEXT: Go to Editor CMS .","title":"riot2"},{"location":"webdav_linux_mount/","text":"Mount webDAV on linux We'll be mounting using davfs2 \u2014 a Linux file system driver that allows to mount a WebDAV resource. Install davfs2 $ cat <<EOF | sudo debconf-set-selections davfs2 davfs2/suid_file boolean false EOF $ sudo apt-get update $ sudo apt install -y davfs2 Reconfigure davfs2 to enable to use davfs under unprivileged users $ sudo dpkg-reconfigure davfs2 Create a directory: $ mkdir ~/.davfs2 create file: $ vim ~/.davfs2/davfs2.conf with contents: `secrets /root/.davfs2/secret` // press a keyboard button to run edit mode --> edit file --> esc --> :w (for saving) --> enter --> :q (to quit the file) --> enter Edit ~/.davfs2/secrets file to add credentials to remote WebDav diectory: $ vim ~/.davfs2/secrets Add a line to the end of file in following style: https://<WebDav URI> <username> <password> eg: http://0.0.0.0:8080/webdav/www admin 123123 Set the permission: $ chmod 600 ~/.davfs2/secrets Make a directory in which you'll mount $ mkdir mount Add a line to /etc/fstab about the remote WebDav directory $ vim /etc/fstab https://<WebDav URI> <mount point> davfs user,noauto,file_mode=600,dir_mode=700 0 1 eg: http://0.0.0.0:8080/webdav/www /root/mount davfs user,noauto,file_mode=600,dir_mode=700 0 1 Add your user to the davfs2 group // check user: $ whoami $ sudo vim /etc/group Add your username as follows: `davfs2:x:134:<username>` eg if the command $ whoami says the user is root : `davfs2:x:134:root` That's it. You can use following commands without being a root user to mount/umount $ mount <mount point> $ umount <mount point> eg: $ mount /root/mount // will ask for username and password: admin 123123 $ umount /root/mount In the next tutorial you will learn about Social SEO. NEXT: Go to Social SEO .","title":"Mount webDAV on linux"},{"location":"webdav_linux_mount/#mount-webdav-on-linux","text":"We'll be mounting using davfs2 \u2014 a Linux file system driver that allows to mount a WebDAV resource. Install davfs2 $ cat <<EOF | sudo debconf-set-selections davfs2 davfs2/suid_file boolean false EOF $ sudo apt-get update $ sudo apt install -y davfs2 Reconfigure davfs2 to enable to use davfs under unprivileged users $ sudo dpkg-reconfigure davfs2 Create a directory: $ mkdir ~/.davfs2 create file: $ vim ~/.davfs2/davfs2.conf with contents: `secrets /root/.davfs2/secret` // press a keyboard button to run edit mode --> edit file --> esc --> :w (for saving) --> enter --> :q (to quit the file) --> enter Edit ~/.davfs2/secrets file to add credentials to remote WebDav diectory: $ vim ~/.davfs2/secrets Add a line to the end of file in following style: https://<WebDav URI> <username> <password> eg: http://0.0.0.0:8080/webdav/www admin 123123 Set the permission: $ chmod 600 ~/.davfs2/secrets Make a directory in which you'll mount $ mkdir mount Add a line to /etc/fstab about the remote WebDav directory $ vim /etc/fstab https://<WebDav URI> <mount point> davfs user,noauto,file_mode=600,dir_mode=700 0 1 eg: http://0.0.0.0:8080/webdav/www /root/mount davfs user,noauto,file_mode=600,dir_mode=700 0 1 Add your user to the davfs2 group // check user: $ whoami $ sudo vim /etc/group Add your username as follows: `davfs2:x:134:<username>` eg if the command $ whoami says the user is root : `davfs2:x:134:root` That's it. You can use following commands without being a root user to mount/umount $ mount <mount point> $ umount <mount point> eg: $ mount /root/mount // will ask for username and password: admin 123123 $ umount /root/mount In the next tutorial you will learn about Social SEO. NEXT: Go to Social SEO .","title":"Mount webDAV on linux"}]}